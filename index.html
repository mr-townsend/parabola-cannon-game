<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parabola Cannon: Outdoor Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0f172a;
            color: #1e293b;
            overflow: hidden;
            touch-action: none;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .input-glow:focus-within {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
            border-color: #3b82f6;
        }
        
        .math-font {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        /* Hide default number input arrows */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        /* Scrollbar for logs */
        .log-scroll::-webkit-scrollbar { width: 6px; }
        .log-scroll::-webkit-scrollbar-track { background: #1e293b; }
        .log-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        
        .toggle-checkbox:checked { background-color: #3b82f6; border-color: #3b82f6; }
    </style>
</head>
<body class="h-screen w-screen flex bg-slate-900">

    <!-- MODE SELECTION OVERLAY -->
    <div id="modeSelectScreen" class="absolute inset-0 z-[60] bg-slate-900 flex flex-col items-center justify-center p-4">
        <div class="max-w-4xl w-full grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="md:col-span-2 text-center mb-8">
                <h1 class="text-5xl md:text-6xl font-bold text-white mb-4 tracking-tight">PARABOLA <span class="text-blue-500">CANNON</span></h1>
                <p class="text-slate-400 text-lg">Select Tactical Mode</p>
            </div>
            <button onclick="startGame('practice')" class="group relative overflow-hidden rounded-3xl bg-slate-800 border-2 border-slate-700 hover:border-blue-500 transition-all duration-300 p-8 text-left hover:shadow-[0_0_40px_rgba(59,130,246,0.3)]">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity"><svg class="w-32 h-32 text-blue-500" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg></div>
                <h2 class="text-3xl font-bold text-white mb-2 group-hover:text-blue-400">Solo Mission</h2>
                <p class="text-slate-400 mb-6">Target practice. Master coordinate geometry against static targets.</p>
                <span class="inline-block bg-blue-600/20 text-blue-400 font-bold py-2 px-4 rounded-lg group-hover:bg-blue-600 group-hover:text-white transition-colors">Start Practice</span>
            </button>
            <button onclick="startGame('versus')" class="group relative overflow-hidden rounded-3xl bg-slate-800 border-2 border-slate-700 hover:border-red-500 transition-all duration-300 p-8 text-left hover:shadow-[0_0_40px_rgba(239,68,68,0.3)]">
                <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity"><svg class="w-32 h-32 text-red-500" fill="currentColor" viewBox="0 0 24 24"><path d="M14.5 17c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3 3 1.35 3 3zm8.5 0c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3 3 1.35 3 3zm-13-7c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3 3 1.35 3 3zm13 0c0 1.65-1.35 3-3 3s-3-1.35-3-3 1.35-3 3-3 3 1.35 3 3z"/></svg></div>
                <h2 class="text-3xl font-bold text-white mb-2 group-hover:text-red-400">1v1 Duel</h2>
                <p class="text-slate-400 mb-6">Versus mode. Take turns adjusting positions. First to 5 points wins.</p>
                <span class="inline-block bg-red-600/20 text-red-400 font-bold py-2 px-4 rounded-lg group-hover:bg-red-600 group-hover:text-white transition-colors">Start Versus</span>
            </button>
        </div>
    </div>

    <!-- GAME OVER OVERLAY -->
    <div id="gameOverScreen" class="hidden absolute inset-0 z-[70] bg-black/90 flex flex-col items-center justify-center p-4">
        <div class="max-w-md w-full bg-slate-800 p-8 rounded-3xl border-4 text-center transform transition-all" id="winCard">
            <h2 class="text-4xl font-bold text-white mb-2" id="winTitle">GAME OVER</h2>
            <p class="text-xl text-slate-400 mb-8" id="winSub">Player X Wins!</p>
            <button onclick="resetGame()" class="w-full bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-4 rounded-xl transition-all shadow-lg text-lg">
                REMATCH
            </button>
            <button onclick="location.reload()" class="mt-4 w-full bg-slate-700 hover:bg-slate-600 text-slate-300 font-bold py-3 rounded-xl transition-all">
                Main Menu
            </button>
        </div>
    </div>

    <!-- MAIN GAME LAYOUT -->
    <div class="flex-grow flex flex-col h-full min-w-0">
        
        <!-- Game Canvas Container -->
        <div class="relative flex-grow bg-slate-900 overflow-hidden">
            <!-- Top HUD -->
            <div class="absolute top-4 left-4 pointer-events-none z-10 flex gap-4">
                <div class="glass-panel px-4 py-2 rounded-xl shadow-lg">
                    <h1 class="text-lg font-bold text-slate-800">PARABOLA CANNON</h1>
                    <p id="modeBadge" class="text-[10px] text-blue-600 font-bold uppercase">Solo Mission</p>
                </div>
                <div id="turnIndicator" class="hidden glass-panel px-4 py-2 rounded-xl shadow-lg border-l-4 border-blue-500 transition-colors">
                    <h2 id="turnText" class="text-lg font-bold text-slate-800">Player 1 Turn</h2>
                </div>
            </div>

            <!-- Game Canvas -->
            <canvas id="gameCanvas" class="w-full h-full cursor-crosshair block"></canvas>
            
            <!-- Instructions Overlay -->
            <div id="instructions" class="hidden absolute inset-0 bg-slate-900/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                <div class="bg-white max-w-lg w-full p-8 rounded-2xl text-center shadow-2xl border border-slate-200">
                    <div class="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-4 text-3xl">üìê</div>
                    <h2 id="instrTitle" class="text-3xl font-bold text-slate-800 mb-2">Field Mission</h2>
                    <p id="instrSub" class="text-slate-500 mb-6 text-sm">Apply coordinate geometry to calculate the projectile trajectory.</p>
                    <div id="instrList" class="text-left space-y-3 bg-slate-50 p-4 rounded-xl border border-slate-100 mb-6 text-slate-700 text-sm"></div>
                    <button onclick="document.getElementById('instructions').classList.add('hidden')" class="w-full bg-slate-800 hover:bg-slate-700 text-white font-bold py-3 rounded-xl transition-all shadow-lg">Ready</button>
                </div>
            </div>
        </div>

        <!-- BOTTOM CONTROL PANEL -->
        <div id="controlPanel" class="h-32 bg-slate-800 border-t border-slate-700 flex items-center justify-between px-6 z-20 shadow-[0_-4px_15px_-3px_rgba(0,0,0,0.3)] shrink-0 transition-colors duration-500">
            
            <div class="flex items-center gap-6">
                <!-- Cannon Pos -->
                <div class="flex flex-col relative border-r border-slate-600 pr-6 mr-2">
                    <label class="text-[10px] text-blue-400 font-bold uppercase mb-1 ml-1" id="cannonXLabel">Cannon X</label>
                    <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                        <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-r border-slate-600 transition-colors" onclick="stepInput('inputCannonX', -1)">-</button>
                        <input type="number" id="inputCannonX" placeholder="0" value="0" class="w-14 bg-transparent text-center text-lg font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                        <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-l border-slate-600 transition-colors" onclick="stepInput('inputCannonX', 1)">+</button>
                    </div>
                </div>

                <!-- STANDARD CONTROLS -->
                <div id="standardControls" class="flex gap-4 items-end">
                    <div class="flex flex-col relative">
                        <label class="text-[10px] text-slate-400 font-bold uppercase mb-1 ml-1">Target X</label>
                        <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                            <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-r border-slate-600 transition-colors" onclick="stepInput('inputX', -1)">-</button>
                            <input type="number" id="inputX" placeholder="0" value="0" class="w-16 bg-transparent text-center text-lg font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                            <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-l border-slate-600 transition-colors" onclick="stepInput('inputX', 1)">+</button>
                        </div>
                    </div>
                    
                    <div class="flex flex-col relative">
                        <label id="labelY" class="text-[10px] text-slate-400 font-bold uppercase mb-1 ml-1">Peak Height (k)</label>
                        <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                            <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-r border-slate-600 transition-colors" onclick="stepInput('inputY', -1)">-</button>
                            <input type="number" id="inputY" placeholder="0" value="0" class="w-16 bg-transparent text-center text-lg font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                            <button class="px-2 py-2 text-slate-400 hover:text-white hover:bg-slate-700 active:bg-slate-600 border-l border-slate-600 transition-colors" onclick="stepInput('inputY', 1)">+</button>
                        </div>
                    </div>
                </div>

                <!-- FORMULA CONTROLS -->
                <div id="formulaControls" class="hidden gap-2 items-center text-slate-300 font-bold text-xl font-mono bg-slate-900/50 p-2 rounded-xl border border-slate-600/50">
                    <span class="text-emerald-400">y =</span>
                    <div class="flex flex-col relative">
                         <label class="text-[8px] text-emerald-400 absolute -top-3 left-1">a</label>
                         <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-r border-slate-600" onclick="stepInput('inputA', -0.1)">-</button>
                            <input type="number" id="inputA" placeholder="-0.1" class="w-12 bg-transparent text-center text-sm font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-l border-slate-600" onclick="stepInput('inputA', 0.1)">+</button>
                         </div>
                    </div>
                    <span>(x - </span>
                    <div class="flex flex-col relative">
                        <label class="text-[8px] text-emerald-400 absolute -top-3 left-1">h</label>
                        <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-r border-slate-600" onclick="stepInput('inputH', -1)">-</button>
                            <input type="number" id="inputH" placeholder="0" class="w-12 bg-transparent text-center text-sm font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-l border-slate-600" onclick="stepInput('inputH', 1)">+</button>
                         </div>
                    </div>
                    <span>)¬≤ + </span>
                    <div class="flex flex-col relative">
                        <label class="text-[8px] text-emerald-400 absolute -top-3 left-1">k</label>
                        <div class="flex items-center input-glow bg-slate-900 rounded-lg border-2 border-slate-600 overflow-hidden">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-r border-slate-600" onclick="stepInput('inputK', -1)">-</button>
                            <input type="number" id="inputK" placeholder="0" class="w-12 bg-transparent text-center text-sm font-bold text-white placeholder-slate-600 appearance-none border-none outline-none">
                            <button class="px-1 py-1 text-slate-400 hover:text-white hover:bg-slate-700 text-xs border-l border-slate-600" onclick="stepInput('inputK', 1)">+</button>
                         </div>
                    </div>
                </div>

                <button id="fireBtn" class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl shadow-lg shadow-blue-900/50 transition-all transform hover:scale-105 active:scale-95 h-[50px] flex items-center border border-blue-400/30 ml-2">
                    FIRE
                </button>
            </div>

            <!-- Settings Button -->
            <div class="relative flex items-center h-full pl-6 border-l border-slate-600">
                <button id="homeBtn" onclick="location.reload()" class="bg-slate-700 hover:bg-red-600 text-slate-300 p-3 rounded-xl transition-all shadow-lg active:scale-95 mr-2" title="Exit to Menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                </button>
                <button id="settingsBtn" class="bg-slate-700 hover:bg-slate-600 text-slate-300 p-3 rounded-xl transition-all shadow-lg active:scale-95 group">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-45 transition-transform"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                </button>

                <!-- Hidden Drawer -->
                <div id="settingsDrawer" class="absolute bottom-[calc(100%+12px)] right-0 bg-slate-800 border border-slate-600 p-5 rounded-xl shadow-2xl flex flex-col gap-4 min-w-[240px] transition-all transform origin-bottom-right scale-0 opacity-0 pointer-events-none z-50">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-widest border-b border-slate-700 pb-2">Mission Settings</h3>
                    
                    <label class="flex items-center justify-between cursor-pointer gap-3 group bg-slate-700/50 p-2 rounded-lg" title="Manipulate the equation directly">
                        <span class="text-xs font-bold text-slate-200 uppercase group-hover:text-emerald-400 transition-colors">Formula Mode</span>
                        <input type="checkbox" id="formulaModeToggle" class="w-5 h-5 accent-emerald-500 rounded cursor-pointer toggle-checkbox bg-slate-700 border-slate-500">
                    </label>

                    <div id="standardSettings" class="flex flex-col gap-4">
                        <label class="flex items-center justify-between cursor-pointer gap-3 group" title="Toggle between Target Y and Vertex Height input">
                            <span class="text-xs font-bold text-slate-300 uppercase group-hover:text-amber-400 transition-colors">Manual Peak Mode</span>
                            <input type="checkbox" id="inputModeToggle" class="w-5 h-5 accent-amber-500 rounded cursor-pointer toggle-checkbox bg-slate-700 border-slate-500" checked>
                        </label>
                    </div>

                    <label class="flex items-center justify-between cursor-pointer gap-3 group" title="Target always at Y=0">
                        <span class="text-xs font-bold text-slate-300 uppercase group-hover:text-blue-400 transition-colors">Ground Targets Only</span>
                        <input type="checkbox" id="groundModeToggle" class="w-5 h-5 accent-blue-600 rounded cursor-pointer toggle-checkbox bg-slate-700 border-slate-500">
                    </label>

                    <label class="flex items-center justify-between cursor-pointer gap-3 group" title="Hide/Show Target Coordinates">
                        <span class="text-xs font-bold text-slate-300 uppercase group-hover:text-emerald-400 transition-colors">Show Coordinates</span>
                        <input type="checkbox" id="showCoordsToggle" class="w-5 h-5 accent-emerald-500 rounded cursor-pointer toggle-checkbox bg-slate-700 border-slate-500">
                    </label>
                </div>
            </div>

        </div>
    </div>

    <!-- RIGHT SIDE: Status & Logs -->
    <div class="w-80 h-full bg-slate-900 border-l border-slate-700 flex flex-col p-4 shadow-2xl z-30 shrink-0">
        <div class="bg-slate-800 rounded-xl p-4 mb-4 border border-slate-700">
            <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3">Mission Stats</h2>
            <div id="statsContent" class="grid grid-cols-2 gap-4"></div>
        </div>
        <div class="bg-slate-800 rounded-xl p-4 mb-4 border border-slate-700">
            <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-3">Trajectory Data</h2>
            <div class="space-y-2">
                <div><p class="text-[10px] text-slate-500 uppercase">Vertex (h, k)</p><p id="vertexDisplay" class="text-lg font-bold text-blue-400 font-mono">--</p></div>
                <div><p class="text-[10px] text-slate-500 uppercase">Equation</p><p id="equationDisplay" class="text-sm font-bold text-emerald-400 math-font tracking-wide">--</p></div>
            </div>
        </div>
        <div class="flex-grow flex flex-col min-h-0">
            <h2 class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2">Mission Log</h2>
            <div id="logContainer" class="bg-slate-950 rounded-xl flex-grow overflow-y-auto p-3 space-y-2 log-scroll font-mono text-xs border border-slate-800">
                <div class="text-slate-600 italic">Select a mode to begin...</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Parabola Cannon: Outdoor Edition v18
         * - Cleaned up Asset Code (No more sprites)
         * - Double Sized Plain Code Cannons
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- ASSET GENERATION ---
        const sprites = { blue: new Image(), red: new Image() };
        let spritesLoaded = { blue: false, red: false };

        function generateCannonSprite(colorStr) {
            const size = 64;
            const c = document.createElement('canvas');
            c.width = size;
            c.height = size;
            const x = c.getContext('2d');
            x.imageSmoothingEnabled = false;
            x.clearRect(0, 0, size, size);
            const p = 4; // 1 "pixel" = 4x4
            const cx = 32; const cy = 32;
            
            // 1. Carriage (Trail)
            x.fillStyle = colorStr;
            x.fillRect(cx - 4*p, cy - 1*p, 6*p, 4*p); 
            x.fillRect(cx - 6*p, cy + 1*p, 4*p, 2*p);

            // 2. Barrel
            x.fillStyle = '#1e293b'; 
            x.fillRect(cx - 1*p, cy - 3*p, 4*p, 4*p);
            x.fillRect(cx + 2*p, cy - 5*p, 3*p, 3*p);
            x.fillRect(cx + 4*p, cy - 7*p, 2*p, 3*p);
            x.fillStyle = '#475569';
            x.fillRect(cx + 2*p, cy - 5*p, 3*p, 1*p);

            // 3. Wheel
            x.fillStyle = '#0f172a';
            x.fillRect(cx - 3*p, cy - 2*p, 6*p, 6*p); 
            x.fillStyle = '#64748b'; 
            x.fillRect(cx - 1*p, cy - 1*p, 2*p, 2*p);
            x.fillStyle = '#fff';
            x.fillRect(cx - 0.5*p, cy - 0.5*p, 1*p, 1*p);

            return c.toDataURL();
        }

        sprites.blue.src = generateCannonSprite('#3b82f6');
        sprites.blue.onload = () => { spritesLoaded.blue = true; };
        sprites.red.src = generateCannonSprite('#ef4444');
        sprites.red.onload = () => { spritesLoaded.red = true; };

        // --- UI REFS ---
        const inputCannonX = document.getElementById('inputCannonX');
        const cannonXLabel = document.getElementById('cannonXLabel');
        const standardControls = document.getElementById('standardControls');
        const formulaControls = document.getElementById('formulaControls');
        const standardSettings = document.getElementById('standardSettings');
        const controlPanel = document.getElementById('controlPanel');
        
        const inputX = document.getElementById('inputX');
        const inputY = document.getElementById('inputY');
        const labelY = document.getElementById('labelY');
        const inputA = document.getElementById('inputA');
        const inputH = document.getElementById('inputH');
        const inputK = document.getElementById('inputK');

        const fireBtn = document.getElementById('fireBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsDrawer = document.getElementById('settingsDrawer');
        const statsContent = document.getElementById('statsContent');
        const vertexDisplay = document.getElementById('vertexDisplay');
        const equationDisplay = document.getElementById('equationDisplay');
        const logContainer = document.getElementById('logContainer');
        const turnIndicator = document.getElementById('turnIndicator');
        const turnText = document.getElementById('turnText');
        const modeBadge = document.getElementById('modeBadge');
        
        const groundModeToggle = document.getElementById('groundModeToggle');
        const inputModeToggle = document.getElementById('inputModeToggle');
        const showCoordsToggle = document.getElementById('showCoordsToggle');
        const formulaModeToggle = document.getElementById('formulaModeToggle');
        
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winCard = document.getElementById('winCard');
        const winTitle = document.getElementById('winTitle');
        const winSub = document.getElementById('winSub');

        // --- GAME STATE ---
        let gameState = {
            mode: null, 
            turn: 1, 
            width: 0,
            height: 0,
            originX: 0,
            originY: 0,
            gridSize: 40,
            p1: { x: -10, score: 0 },
            p2: { x: 10, score: 0 },
            practiceTarget: { x: 0, y: 0 },
            practiceScore: 0,
            practiceStreak: 0,
            projectiles: [],
            persistentTrails: [], 
            explosions: [],
            craters: [], 
            isFiring: false,
            cannonX: 0,
            gameOver: false
        };

        const CONSTANTS = { BARRIER_LIMIT: 4, WIN_SCORE: 5 };
        const COLORS = {
            skyTop: '#60a5fa', skyBottom: '#bfdbfe', ground: '#4ade80', groundDark: '#22c55e', 
            grid: 'rgba(255,255,255,0.4)', axis: 'rgba(0,0,0,0.6)', text: 'rgba(0,0,0,0.5)',
            player1: '#3b82f6', player2: '#ef4444', projectile: '#111827', barrier: 'rgba(255, 0, 0, 0.1)', barrierLine: 'rgba(255, 0, 0, 0.4)'
        };

        // --- INPUT STEPPER LOGIC ---
        window.stepInput = function(id, step) {
            const input = document.getElementById(id);
            let val = parseFloat(input.value) || 0;
            val += step;
            // Round to avoid floating point errors
            if (step % 1 !== 0) val = Math.round(val * 10) / 10;
            input.value = val;
            // Trigger input event manually so game logic updates
            input.dispatchEvent(new Event('input'));
        };

        // --- INITIALIZATION ---
        function startGame(mode) {
            gameState.mode = mode;
            gameState.gameOver = false;
            document.getElementById('modeSelectScreen').style.display = 'none';
            document.getElementById('instructions').classList.remove('hidden');
            gameOverScreen.classList.add('hidden');

            const instrList = document.getElementById('instrList');
            instrList.innerHTML = ''; 

            if (mode === 'practice') {
                modeBadge.textContent = "Solo Mission";
                modeBadge.className = "text-[10px] text-blue-600 font-bold uppercase";
                gameState.p1.x = 0; 
                inputCannonX.value = 0;
                instrList.innerHTML = `<p>1. Set <b>Cannon X</b> to move.</p><p>2. Find <b>Target</b> coordinates.</p><p>3. Input values or Formula.</p><p>4. Fire!</p>`;
                spawnPracticeTarget();
                updateStatsUI();
            } else {
                modeBadge.textContent = "1v1 Duel";
                modeBadge.className = "text-[10px] text-purple-600 font-bold uppercase";
                gameState.p1.x = -12; gameState.p1.score = 0;
                gameState.p2.x = 12; gameState.p2.score = 0;
                gameState.turn = 1;
                instrList.innerHTML = `<p>1. <b>Player 1 (Blue)</b> goes first.</p><p>2. Stay on your side of the <b>Red Barrier</b>.</p><p>3. Aim at <b>Player 2 (Red)</b>.</p><p>4. First to 5 points wins!</p>`;
                startTurn(1);
            }
            initCanvas();
        }

        function resetGame() {
            gameState.p1.score = 0;
            gameState.p2.score = 0;
            gameState.practiceScore = 0;
            gameState.practiceStreak = 0;
            gameState.craters = [];
            gameState.persistentTrails = [];
            gameState.gameOver = false;
            gameOverScreen.classList.add('hidden');
            if (gameState.mode === 'versus') {
                gameState.p1.x = -12; gameState.p2.x = 12;
                startTurn(1);
            } else {
                gameState.p1.x = 0; inputCannonX.value = 0;
                spawnPracticeTarget();
            }
            updateStatsUI();
        }

        function initCanvas() {
            window.addEventListener('resize', resize);
            resize();
            gameLoop();
            setTimeout(() => inputX.focus(), 100);
            updateUIModes();
        }

        function resize() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            gameState.width = canvas.width;
            gameState.height = canvas.height;
            gameState.originX = Math.floor(gameState.width * 0.5); 
            gameState.originY = Math.floor(gameState.height * 0.82); 
            gameState.gridSize = Math.max(Math.floor(gameState.width / 40), 20);
        }

        function startTurn(playerNum) {
            gameState.turn = playerNum;
            const isP1 = playerNum === 1;
            turnIndicator.classList.remove('hidden');
            turnIndicator.className = `glass-panel px-4 py-2 rounded-xl shadow-lg border-l-4 transition-colors ${isP1 ? 'border-blue-500' : 'border-red-500'}`;
            turnText.textContent = isP1 ? "Player 1 Turn" : "Player 2 Turn";
            turnText.className = `text-lg font-bold ${isP1 ? 'text-blue-700' : 'text-red-700'}`;
            controlPanel.className = `h-32 border-t flex items-center justify-between px-6 z-20 shadow-[0_-4px_15px_-3px_rgba(0,0,0,0.3)] shrink-0 transition-colors duration-500 ${isP1 ? 'bg-slate-800 border-slate-700' : 'bg-red-900/20 border-red-900/50'}`;
            cannonXLabel.textContent = isP1 ? "P1 Cannon X" : "P2 Cannon X";
            cannonXLabel.className = `text-[10px] font-bold uppercase mb-1 ml-1 ${isP1 ? 'text-blue-400' : 'text-red-400'}`;
            inputCannonX.value = isP1 ? gameState.p1.x : gameState.p2.x; 
            inputX.value = ''; inputY.value = ''; inputA.value = ''; inputH.value = ''; inputK.value = '';
            gameState.cannonX = isP1 ? gameState.p1.x : gameState.p2.x;
            logEvent(`Round Start: Player ${playerNum}`, 'info');
            updateStatsUI();
        }

        function updateStatsUI() {
            if (gameState.mode === 'practice') {
                statsContent.innerHTML = `
                    <div><p class="text-[10px] text-slate-500 uppercase">Score</p><p class="text-2xl font-bold text-emerald-400">${gameState.practiceScore}</p></div>
                    <div><p class="text-[10px] text-slate-500 uppercase">Streak</p><p class="text-2xl font-bold text-amber-400">${gameState.practiceStreak}</p></div>`;
            } else {
                statsContent.innerHTML = `
                    <div><p class="text-[10px] text-blue-500 uppercase">P1 Score</p><p class="text-2xl font-bold text-blue-400">${gameState.p1.score}</p></div>
                    <div><p class="text-[10px] text-red-500 uppercase">P2 Score</p><p class="text-2xl font-bold text-red-400">${gameState.p2.score}</p></div>`;
            }
        }

        function spawnPracticeTarget() {
            const range = Math.floor((gameState.width/2) / gameState.gridSize) - 2;
            let newX = Math.floor(Math.random() * range * 2) - range;
            if (newX === 0) newX = 5;
            let newY = !groundModeToggle.checked ? Math.floor(Math.random() * 8) + 1 : 0;
            gameState.practiceTarget = { x: newX, y: newY };
            logEvent(`New Target at (${newX}, ${newY})`, 'info');
        }

        function toScreen(x, y) {
            return {
                x: gameState.originX + (x * gameState.gridSize),
                y: gameState.originY - (y * gameState.gridSize) 
            };
        }

        function fire() {
            if (gameState.isFiring || gameState.gameOver) return;

            let newCannonX = parseFloat(inputCannonX.value) || 0;
            if (gameState.mode === 'versus') {
                if (gameState.turn === 1) {
                    if (newCannonX > -CONSTANTS.BARRIER_LIMIT) newCannonX = -CONSTANTS.BARRIER_LIMIT;
                    gameState.p1.x = newCannonX;
                } else {
                    if (newCannonX < CONSTANTS.BARRIER_LIMIT) newCannonX = CONSTANTS.BARRIER_LIMIT;
                    gameState.p2.x = newCannonX;
                }
                inputCannonX.value = newCannonX; 
            } else {
                gameState.p1.x = newCannonX; 
            }

            gameState.isFiring = true;
            gameState.persistentTrails = [];

            let h, k, a;
            let dir = 1; // Default direction

            const startX = (gameState.mode === 'versus' && gameState.turn === 2) ? gameState.p2.x : gameState.p1.x;

            if (formulaModeToggle.checked) {
                a = parseFloat(inputA.value) || -0.1; h = parseFloat(inputH.value) || 0; k = parseFloat(inputK.value) || 0;
                if (a === 0) a = 0.00001; 
                
                // Formula Mode Direction: Towards the vertex 'h'
                dir = (h >= startX) ? 1 : -1;
            } else {
                const valX = parseFloat(inputX.value); const valY = parseFloat(inputY.value);
                if (isNaN(valX) || isNaN(valY)) { logEvent("Coordinates required.", "error"); gameState.isFiring = false; return; }
                
                // Standard Mode Direction: Explicitly towards the target X
                dir = (valX >= startX) ? 1 : -1;

                if (inputModeToggle.checked) {
                    const dist = valX - startX; h = startX + (dist / 2); k = valY;
                    const denom = Math.pow(startX - h, 2); a = denom === 0 ? 0 : -k / denom;
                } else {
                    const dist = valX - startX; const midX = startX + (dist / 2); h = midX;
                    k = Math.max(0, valY) + Math.abs(dist)/2 + 5; a = -k / Math.pow(startX - h, 2);
                }
            }

            vertexDisplay.innerText = `(${h.toFixed(1)}, ${k.toFixed(1)})`;
            equationDisplay.innerText = `y = ${a.toFixed(3)}(x - ${h.toFixed(1)})¬≤ + ${k.toFixed(1)}`;
            logEvent(`Fired: y=${a.toFixed(2)}(x-${h.toFixed(1)})¬≤ + ${k}`);

            // Store 'dir' in the projectile object
            gameState.projectiles.push({
                startX: startX, currentGridX: startX, controlH: h, controlK: k, controlA: a, shooter: gameState.turn,
                direction: dir 
            });
        }

        function checkHit(gridX, gridY, shooter) {
            let hit = false;
            if (gameState.mode === 'practice') {
                const dist = Math.sqrt(Math.pow(gridX - gameState.practiceTarget.x, 2) + Math.pow(gridY - gameState.practiceTarget.y, 2));
                if (dist < 0.8) {
                    gameState.practiceScore += 100; gameState.practiceStreak++;
                    logEvent("Target Destroyed!", "success");
                    addExplosion(toScreen(gameState.practiceTarget.x, gameState.practiceTarget.y), true);
                    gameState.craters = [];
                    setTimeout(() => { spawnTargetLogic(); gameState.isFiring = false; }, 2000);
                    hit = true;
                }
            } else {
                const target = shooter === 1 ? gameState.p2 : gameState.p1;
                const dist = Math.sqrt(Math.pow(gridX - target.x, 2) + Math.pow(gridY - 0, 2)); 
                if (dist < 1.0) {
                    if (shooter === 1) gameState.p1.score++; else gameState.p2.score++;
                    logEvent(`DIRECT HIT on Player ${shooter === 1 ? '2' : '1'}!`, "success");
                    addExplosion(toScreen(target.x, 0), true);
                    gameState.craters = [];
                    hit = true;
                    updateStatsUI();
                    
                    // WIN CHECK
                    if (gameState.p1.score >= CONSTANTS.WIN_SCORE || gameState.p2.score >= CONSTANTS.WIN_SCORE) {
                        gameState.gameOver = true;
                        setTimeout(() => {
                            gameOverScreen.classList.remove('hidden');
                            winTitle.innerText = "VICTORY!";
                            if(gameState.p1.score >= CONSTANTS.WIN_SCORE) {
                                winSub.innerText = "Player 1 (Blue) Wins!";
                                winCard.className = "max-w-md w-full bg-slate-800 p-8 rounded-3xl border-4 border-blue-500 text-center transform transition-all";
                            } else {
                                winSub.innerText = "Player 2 (Red) Wins!";
                                winCard.className = "max-w-md w-full bg-slate-800 p-8 rounded-3xl border-4 border-red-500 text-center transform transition-all";
                            }
                        }, 1000);
                        return;
                    }

                    setTimeout(() => { gameState.isFiring = false; startTurn(shooter === 1 ? 2 : 1); }, 2000);
                }
            }

            if (!hit) {
                addExplosion(toScreen(gridX, gridY), false);
                gameState.craters.push({x: gridX, y: gridY});
                if (gameState.craters.length > 50) gameState.craters.shift();
                logEvent(`Missed at (${gridX.toFixed(1)}, ${gridY.toFixed(1)})`, 'warning');
                if (gameState.mode === 'versus') {
                    setTimeout(() => { gameState.isFiring = false; startTurn(shooter === 1 ? 2 : 1); }, 1000);
                } else {
                    gameState.practiceStreak = 0; gameState.isFiring = false;
                }
            }
            updateStatsUI();
        }

        function spawnTargetLogic() { if (gameState.mode === 'practice') spawnPracticeTarget(); }
        function addExplosion(pos, isBig) { gameState.explosions.push({x: pos.x, y: pos.y, radius: 1, maxRadius: isBig ? 100 : 30, alpha: 1, color: isBig ? '#fbbf24' : '#94a3b8'}); }
        function logEvent(msg, type = 'info') {
            const div = document.createElement('div'); div.textContent = `> ${msg}`;
            div.className = type === 'error' ? 'text-red-400 font-bold' : type === 'success' ? 'text-emerald-400 font-bold' : type === 'warning' ? 'text-amber-400' : 'text-slate-300';
            logContainer.prepend(div);
            if (logContainer.children.length > 50) logContainer.removeChild(logContainer.lastChild);
        }

        function updateUIModes() {
            if (formulaModeToggle.checked) {
                standardControls.classList.add('hidden'); formulaControls.classList.remove('hidden'); formulaControls.classList.add('flex'); standardSettings.classList.add('opacity-50', 'pointer-events-none');
            } else {
                standardControls.classList.remove('hidden'); formulaControls.classList.add('hidden'); formulaControls.classList.remove('flex'); standardSettings.classList.remove('opacity-50', 'pointer-events-none');
            }
            labelY.textContent = inputModeToggle.checked ? "Peak Height (k)" : "Target Y";
        }

        inputCannonX.addEventListener('input', () => {
             let val = parseFloat(inputCannonX.value) || 0;
             if (gameState.mode === 'versus') {
                 if (gameState.turn === 1) { if (val > -CONSTANTS.BARRIER_LIMIT) val = -CONSTANTS.BARRIER_LIMIT; } 
                 else { if (val < CONSTANTS.BARRIER_LIMIT) val = CONSTANTS.BARRIER_LIMIT; }
             }
             gameState.cannonX = val;
        });

        // --- DRAWING ---
        function drawCannon(xGrid, color, direction = 1) {
            const pos = toScreen(xGrid, 0);
            const scale = gameState.gridSize / 40;
            // DOUBLE SIZE from original
            const s = scale * 2; 
            
            ctx.save();
            ctx.translate(pos.x, pos.y - 10*scale); 
            if (direction === -1) ctx.scale(-1, 1);
            
            // 1. Draw Barrel (Background Layer)
            // We save/restore context here so the rotation doesn't affect the wheels
            ctx.save();
            ctx.rotate(-Math.PI / 4); 
            ctx.fillStyle = '#334155'; ctx.fillRect(-10*s, -8*s, 20*s, 16*s); // Recoil block
            ctx.fillStyle = '#0f172a'; ctx.fillRect(0, -5*s, 40*s, 10*s); // Long barrel
            ctx.restore();

            // 2. Draw Wheels (Foreground Layer)
            // Wheels (Outer)
            ctx.fillStyle = '#1e293b'; 
            ctx.beginPath(); ctx.arc(0, 5*s, 12*s, 0, Math.PI*2); ctx.fill();
            // Wheel (Inner Color)
            ctx.fillStyle = color; 
            ctx.beginPath(); ctx.arc(0, 5*s, 5*s, 0, Math.PI*2); ctx.fill();
            
            // Spokes
            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 3*s;
            ctx.beginPath(); ctx.moveTo(-8*s, 5*s); ctx.lineTo(8*s, 5*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -3*s); ctx.lineTo(0, 13*s); ctx.stroke();

            ctx.restore();
            
            ctx.fillStyle = color; 
            ctx.font = "bold 14px sans-serif"; 
            ctx.textAlign = "center"; 
            ctx.fillText(`${xGrid}`, pos.x, pos.y + 35);
        }

        function drawEntities() {
            if (gameState.mode === 'versus') {
                const leftLimit = toScreen(-CONSTANTS.BARRIER_LIMIT, 0).x;
                const rightLimit = toScreen(CONSTANTS.BARRIER_LIMIT, 0).x;
                ctx.fillStyle = COLORS.barrier; ctx.fillRect(leftLimit, 0, rightLimit - leftLimit, gameState.height);
                ctx.strokeStyle = COLORS.barrierLine; ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                ctx.beginPath(); ctx.moveTo(leftLimit, 0); ctx.lineTo(leftLimit, gameState.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(rightLimit, 0); ctx.lineTo(rightLimit, gameState.height); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255, 100, 100, 0.5)'; ctx.font = "bold 14px sans-serif"; ctx.fillText("DMZ", (leftLimit + rightLimit)/2, 50);
            }
            gameState.craters.forEach(c => {
                const pos = toScreen(c.x, c.y);
                ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(pos.x, pos.y, gameState.gridSize*0.3, gameState.gridSize*0.15, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = "10px sans-serif"; ctx.fillText("X", pos.x, pos.y+3);
            });
            if (gameState.mode === 'practice') {
                const t = gameState.practiceTarget;
                const pos = toScreen(t.x, t.y);
                const scale = gameState.gridSize / 40;
                ctx.fillStyle = '#475569'; ctx.fillRect(pos.x-2*scale, pos.y, 4*scale, 20*scale); 
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 16*scale, 0, Math.PI*2); ctx.fillStyle = '#ef4444'; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 10*scale, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 4*scale, 0, Math.PI*2); ctx.fillStyle = '#ef4444'; ctx.fill();
                if (showCoordsToggle.checked) { ctx.fillStyle = '#ef4444'; ctx.font = "bold 12px sans-serif"; ctx.fillText(`(${t.x}, ${t.y})`, pos.x, pos.y-25*scale); }
                const dir = (gameState.p1.x <= t.x) ? 1 : -1;
                drawCannon(gameState.p1.x, COLORS.player1, dir);
            } else {
                let p1Pos = gameState.p1.x; let p2Pos = gameState.p2.x;
                if (gameState.turn === 1) p1Pos = gameState.cannonX; else p2Pos = gameState.cannonX;
                const p1Dir = (p1Pos <= p2Pos) ? 1 : -1; const p2Dir = (p2Pos <= p1Pos) ? 1 : -1;
                drawCannon(p1Pos, COLORS.player1, p1Dir);
                drawCannon(p2Pos, COLORS.player2, p2Dir);
            }
        }

        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, gameState.height);
            grad.addColorStop(0, COLORS.skyTop); grad.addColorStop(0.65, COLORS.skyBottom); grad.addColorStop(0.65, COLORS.ground); grad.addColorStop(1, COLORS.groundDark);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, gameState.width, gameState.height);
            const groundY = gameState.originY;
            ctx.fillStyle = COLORS.ground; ctx.fillRect(0, groundY, gameState.width, gameState.height - groundY);
        }

        function drawGrid() {
            ctx.lineWidth = 1; ctx.font = "12px JetBrains Mono"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            const xStart = -Math.floor(gameState.originX/gameState.gridSize)-1; const xEnd = Math.floor((gameState.width-gameState.originX)/gameState.gridSize)+1;
            const yStart = -Math.floor((gameState.height-gameState.originY)/gameState.gridSize)-1; const yEnd = Math.floor(gameState.originY/gameState.gridSize)+1;
            for(let i=xStart; i<=xEnd; i++) {
                const x = gameState.originX + (i*gameState.gridSize);
                ctx.strokeStyle = i===0 ? COLORS.axis : COLORS.grid; ctx.lineWidth = i===0 ? 2 : 1;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, gameState.height); ctx.stroke();
                if(i!==0 && i%2===0) { ctx.fillStyle = COLORS.text; ctx.fillText(i, x, gameState.originY+18); }
            }
            for(let j=yStart; j<=yEnd; j++) {
                const y = gameState.originY - (j*gameState.gridSize);
                ctx.strokeStyle = j===0 ? COLORS.axis : COLORS.grid; ctx.lineWidth = j===0 ? 2 : 1;
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(gameState.width, y); ctx.stroke();
                if(j!==0 && j%2===0) { ctx.fillStyle = COLORS.text; ctx.fillText(j, gameState.originX-18, y); }
            }
            ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(gameState.originX, gameState.originY, 4, 0, Math.PI * 2); ctx.fill();
        }

        function updateAndDrawProjectiles() {
            if (gameState.persistentTrails.length > 0) {
                gameState.persistentTrails.forEach(trail => {
                    ctx.beginPath(); ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)'; ctx.setLineDash([5, 5]); ctx.lineWidth = 2;
                    const step = (trail.endX >= trail.startX) ? 0.2 : -0.2;
                    if(Math.abs(step) < 0.01) return;
                    let started = false;
                    for(let gx = trail.startX; (step>0 ? gx<=trail.endX : gx>=trail.endX); gx+=step) {
                        let gy = 0; if (trail.a !== 0) gy = trail.a * Math.pow(gx - trail.h, 2) + trail.k;
                        const sPos = toScreen(gx, gy); if (!started) { ctx.moveTo(sPos.x, sPos.y); started=true; } else { ctx.lineTo(sPos.x, sPos.y); }
                    }
                    ctx.stroke(); ctx.setLineDash([]);
                });
            }
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i]; const speed = 0.25; 
                
                // USE STORED DIRECTION
                p.currentGridX += (speed * p.direction);
                
                let currentGridY = 0;
                if (p.controlA !== 0) currentGridY = p.controlA * Math.pow(p.currentGridX - p.controlH, 2) + p.controlK;
                const hitGround = currentGridY < -2;
                const farOffScreen = Math.abs(p.currentGridX) > (gameState.width/gameState.gridSize) + 50; 
                const deepUnderground = currentGridY < -50; 
                if (hitGround || farOffScreen || deepUnderground) {
                    gameState.persistentTrails.push({ startX: p.startX, endX: p.currentGridX, h: p.controlH, k: p.controlK, a: p.controlA });
                    checkHit(p.currentGridX, currentGridY, p.shooter); gameState.projectiles.splice(i, 1); continue;
                }
                const target = (p.shooter === 1) ? gameState.p2 : gameState.p1;
                const tX = (gameState.mode === 'versus') ? target.x : gameState.practiceTarget.x;
                const tY = (gameState.mode === 'versus') ? 0 : gameState.practiceTarget.y;
                const distToTarget = Math.sqrt(Math.pow(p.currentGridX - tX, 2) + Math.pow(currentGridY - tY, 2));
                if (distToTarget < 0.8) {
                    gameState.persistentTrails.push({ startX: p.startX, endX: p.currentGridX, h: p.controlH, k: p.controlK, a: p.controlA });
                    checkHit(p.currentGridX, currentGridY, p.shooter); gameState.projectiles.splice(i, 1); continue;
                }
                ctx.beginPath(); ctx.strokeStyle = 'rgba(30, 41, 59, 0.6)'; ctx.setLineDash([4, 4]); ctx.lineWidth = 2;
                const startY = p.controlA * Math.pow(p.startX - p.controlH, 2) + p.controlK;
                const startScreen = toScreen(p.startX, startY);
                ctx.moveTo(startScreen.x, startScreen.y);
                
                // Draw using stored direction
                for(let gx = p.startX; (p.direction>0 ? gx<=p.currentGridX : gx>=p.currentGridX); gx+=(p.direction*0.2)) {
                   let gy = 0; if (p.controlA !== 0) gy = p.controlA * Math.pow(gx - p.controlH, 2) + p.controlK;
                   const screenP = toScreen(gx, gy); ctx.lineTo(screenP.x, screenP.y);
                }
                const finalPos = toScreen(p.currentGridX, currentGridY); ctx.lineTo(finalPos.x, finalPos.y); ctx.stroke(); ctx.setLineDash([]);
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(finalPos.x, finalPos.y, 5, 0, Math.PI * 2); ctx.fill();
            }
        }

        function updateAndDrawExplosions() {
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const ex = gameState.explosions[i]; ex.radius += 1.5; ex.alpha -= 0.03;
                if (ex.alpha <= 0) { gameState.explosions.splice(i, 1); continue; }
                ctx.save(); ctx.globalAlpha = ex.alpha; ctx.fillStyle = ex.color;
                ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2); ctx.fill();
                if (ex.type === 'target') { ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius * 0.8, 0, Math.PI * 2); ctx.stroke(); }
                ctx.restore();
            }
        }

        function gameLoop() {
            drawBackground(); drawGrid(); drawEntities(); updateAndDrawProjectiles(); updateAndDrawExplosions(); requestAnimationFrame(gameLoop);
        }

        fireBtn.addEventListener('click', fire);
        window.addEventListener('keydown', (e) => { if (e.key === 'Enter') fire(); });
        groundModeToggle.addEventListener('change', () => { spawnTarget(); });
        inputModeToggle.addEventListener('change', updateUIModes);
        formulaModeToggle.addEventListener('change', updateUIModes);
        
        let isDrawerOpen = false;
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation(); isDrawerOpen = !isDrawerOpen;
            settingsDrawer.classList.toggle('scale-0', !isDrawerOpen); settingsDrawer.classList.toggle('opacity-0', !isDrawerOpen);
            settingsDrawer.classList.toggle('pointer-events-none', !isDrawerOpen); settingsDrawer.classList.toggle('scale-100', isDrawerOpen);
            settingsDrawer.classList.toggle('opacity-100', isDrawerOpen); settingsDrawer.classList.toggle('pointer-events-auto', isDrawerOpen);
        });
        document.addEventListener('click', (e) => {
            if (isDrawerOpen && !settingsDrawer.contains(e.target) && e.target !== settingsBtn) {
                isDrawerOpen = false;
                settingsDrawer.classList.add('scale-0', 'opacity-0', 'pointer-events-none'); settingsDrawer.classList.remove('scale-100', 'opacity-100', 'pointer-events-auto');
            }
        });

        resize(); drawBackground();
    </script>
</body>
</html>
